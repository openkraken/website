# Kraken Architecture Overview

## Preface

Kraken is a self-drawn rendering engine based on Flutter. It uses W3C standard HTML, CSS, JavaScript, and supports real-time interaction of the screen through JavaScript.

Kraken has been deeply customized based on the implementation of the Flutter Rendering layer. While retaining the compatibility with the RenderObject API, it has expanded the layout capabilities compatible with the W3C standard, and added DOM and CSS parsing processing on this basis, and docked with the JavaScript engine. , which implements a browser-like technical architecture:

<img src="https://kraken.oss-cn-hangzhou.aliyuncs.com/images/20220406122844.jpg" width="500" />

## Bridge layer introduction

The Bridge layer provides users with a JavaScript runtime environment based on the ECMAScript standard, and has built-in W3C standard DOM API and BOM API.

**JavaScript Engine used by Kraken**

Kraken's JavaScript Engine is QuickJS, which supports most of the functions of the ECMA 2020 standard. QuickJS not only supports parsing JavaScript code, but also supports offline conversion of JavaScript to ByteCode format, and then directly parses ByteCode to run. This subtracts the time of the Parse phase during page load.

Through QuickJS Binding, Kraken uses C/C++ to implement most of the functions in the DOM standard, including Node, EventTarget, Element, selectors, etc.

Some front-end frameworks based on DOM standards can run without changing a single line of code, such as the popular React.js, Vue.js and Rax.js.

The specific implementation details and performance optimization will be introduced in a separate article later.

**HTML parsing**

HTML text entered by the user is also parsed at the bridge layer. An HTML Parser is built into the bridge for parsing HTML strings written by users. After parsing the HTML string, a set of DOM node calls are generated, which in turn create DOM objects.

**Communication between C++ and Dart**

Below the Bridge layer is the Framework layer implemented in Dart. Kraken's C++ code communicates with the Framework layer through Dart FFI. In Kraken, both C++ and Dart environments contain `BindingObject` objects, which are the main bridge for communication between C++ and Dart. Various operations such as node operations created by the user code by calling the DOM API will be converted into instructions and sent to the Framework layer in batches for processing.

The specific details will be introduced in a separate article in the future.

**Plugin Capability**

In addition to the functionality provided by Kraken, plugin functionality is also provided to users. It allows users to extend new Elements through JavaScript and realize native rendering capabilities through Flutter Widget.

The Kraken team officially maintains some plugins, which can be used as demonstration codes for reference: https://github.com/openkraken/plugins.

The Bridge layer supports the plug-in capabilities by intercepting the user's property calls and method calls, and sending the calls to the Framework side through the BindingObject channel, and calling some life cycles of the Framework layer Element. This allows users to perceive changes in the JavaScript environment using the rendering code written by the Flutter Widget.

The specific details will be introduced in a separate article in the future.

## Framework layer introduction

The Framework is written in Dart language and driven by the operation instructions passed from the C++ layer.

**DOM tree**

The DOM tree is not only the structure tree generated by the user through the JavaScript API, but also responsible for other functional modules connected to the Framework layer, including calling CSS parsing and processing, and generating RenderObjects to complete layout and drawing operations. For some user gesture operations, the DOM node will also trigger corresponding events to call the registered JavaScript functions.

Elements contain very complex functions, including node manipulation, handling of HTML attributes, event registration and binding, and contains a lot of life cycle, user processing CSS and RenderObject.

The specific details will be introduced in a separate article in the future.

**CSS styling**

The CSS code inline by the user through the Style tag and the inlineStyle set through the JavaScript API will be forwarded to the CSS style processing module through the DOM tree. This module contains the parsing of CSS text, and the parsing of value types.

CSS animation is an important part of CSS module, including the implementation of transition and animation. These operations will in turn modify the DOM node to achieve animation control.

CSS also contains some very complex layout features. Such as position: absolute, display: flex, etc. And these functions are completed by the CSS module, the DOM tree and the layout module that will be introduced later. The CSS module is mainly responsible for setting the style, the DOM tree is responsible for creating the corresponding RenderObject, and the layout module is to implement the layout algorithm.

The specific details will be introduced in a separate article in the future.

**Flutter Widget extension support**

Since version 0.10, Kraken supports the use of Flutter Widget to develop custom Element extensions. Kraken implements a bridging layer that connects the life cycle of the DOM tree with the life cycle of Flutter Element. In this way, Flutter Widget can be driven, and Flutter Widget can be used to draw and render content within the scope of a Kraken Element, and it also supports multi-layer nesting, which perfectly bridges the boundary between the Web and Flutter ecology. Let the simple and flexible layout of the web and the friendly blend of Flutter Widget for rendering.

The specific details will be introduced in a separate article in the future.

**Module extension**

In addition to custom rendering, Kraken's extensibility also supports the ability to use Dart to enrich JavaScript. Through Module extension, you can easily inject new JavaScript APIs in the JavaScript environment, and use Dart to achieve the capabilities users want.

The specific details will be introduced in a separate article in the future.

**Debugging Tools**

The Chrome Developer Protocol-based debugging service implementation is built into the Kraken module. You can use the Chrome browser to connect and debug Kraken pages through the Chrome Developer Tools. Currently supports debugging Element structure, viewing CSS styles, intercepting Network requests, and will support the JavaScript Debugger function in May 2022.

The debugging tool will start a WebSocket debugging service locally in the application, exchange data with the browser debugging tool through the Chrome Developer Protocol, and pass the current running information of Kraken to the debugging tool for debugging.

The specific details will be introduced in a separate article in the future.

**Gesture Handling**

Many gesture operations are defined in the W3C standard, such as touchstart, click, etc. Kraken's Gesture module is responsible for the computation and processing of this part. When the user touches the screen, the Flutter Engine will send the original touch and click information to the gesture processing module, and the gesture processing module determines which type of the current user's gesture operation belongs to. Finally, check whether there is an event currently bound to this event type. If there is, throw the event to the DOM tree, and then use the DOM node to trigger the bound JavaScript function.

Another core function of gesture processing is the recognition of scroll gestures. In mobile applications, scrolling is the most common operation, and the gesture processing module can accurately identify which scroll gestures are, and calculate the scrolling acceleration, and built-in mathematical functions to derive the displacement for a period of time in the future. Finally, the values ​​of these displacements will be transmitted to the drawing module described later in real time to realize the scrolling effect.

The specific details will be introduced in a separate article in the future.

**Layout Module**

The layout style set by the user through CSS, such as display: flex, position: absolute, etc. The corresponding calculation algorithm will be called in the layout module, such as the flex layout algorithm module and the flow layout algorithm module. The main thing of the layout module is to convert the properties set by the CSS module into dimensions and coordinates through calculation. Let each RenderObject get the size it occupies on the screen and the position coordinates relative to the upper left corner.

The layout module is also the most complex module in Kraken. In the W3C standard, the combination of different styles will bring about various effects, and these combined functions will also be implemented one by one in the layout module.

The specific details will be introduced in a separate article in the future.

**Drawing module**

The drawing module is the last module implemented in Kraken, and all subsequent operations will be handed over to Flutter for processing. After the layout module completes its work and determines the size and coordinates of each RenderObject, the drawing module will call the graphics API to draw the image on the existing coordinates. Flutter Engine provides a drawing API similar to Canvas, and the drawing module implements the processing of image operations such as border and color through these APIs.

Image operation is a relatively performance-intensive operation, so the drawing module includes many optimization methods to optimize image drawing performance.

The specific details will be introduced in a separate article in the future.

## Summary

This article introduces the main layered design functions of Kraken and gives a brief introduction. The Kraken team will regularly release the specific implementation details of each layer.
